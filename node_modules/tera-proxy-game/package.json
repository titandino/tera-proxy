{
  "_args": [
    [
      {
        "raw": "tera-proxy-game@github:meishuu/tera-proxy-game",
        "scope": null,
        "escapedName": "tera-proxy-game",
        "name": "tera-proxy-game",
        "rawSpec": "github:meishuu/tera-proxy-game",
        "spec": "github:meishuu/tera-proxy-game",
        "type": "hosted",
        "hosted": {
          "type": "github",
          "ssh": "git@github.com:meishuu/tera-proxy-game.git",
          "sshUrl": "git+ssh://git@github.com/meishuu/tera-proxy-game.git",
          "httpsUrl": "git+https://github.com/meishuu/tera-proxy-game.git",
          "gitUrl": "git://github.com/meishuu/tera-proxy-game.git",
          "shortcut": "github:meishuu/tera-proxy-game",
          "directUrl": "https://raw.githubusercontent.com/meishuu/tera-proxy-game/master/package.json"
        }
      },
      "C:\\Users\\Trenton\\desktop\\tera-proxy"
    ]
  ],
  "_from": "meishuu/tera-proxy-game",
  "_id": "tera-proxy-game@1.0.0",
  "_inCache": true,
  "_location": "/tera-proxy-game",
  "_phantomChildren": {},
  "_requested": {
    "raw": "tera-proxy-game@github:meishuu/tera-proxy-game",
    "scope": null,
    "escapedName": "tera-proxy-game",
    "name": "tera-proxy-game",
    "rawSpec": "github:meishuu/tera-proxy-game",
    "spec": "github:meishuu/tera-proxy-game",
    "type": "hosted",
    "hosted": {
      "type": "github",
      "ssh": "git@github.com:meishuu/tera-proxy-game.git",
      "sshUrl": "git+ssh://git@github.com/meishuu/tera-proxy-game.git",
      "httpsUrl": "git+https://github.com/meishuu/tera-proxy-game.git",
      "gitUrl": "git://github.com/meishuu/tera-proxy-game.git",
      "shortcut": "github:meishuu/tera-proxy-game",
      "directUrl": "https://raw.githubusercontent.com/meishuu/tera-proxy-game/master/package.json"
    }
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "git://github.com/meishuu/tera-proxy-game.git#3e704964ff2cc8b38a2f3e7b80045722f5da9aab",
  "_shasum": "b256a9fca983f6d74d17a1c618109d8862c1f55a",
  "_shrinkwrap": null,
  "_spec": "tera-proxy-game@github:meishuu/tera-proxy-game",
  "_where": "C:\\Users\\Trenton\\desktop\\tera-proxy",
  "author": {
    "name": "meishu"
  },
  "bugs": {
    "url": "https://github.com/meishuu/tera-proxy-game/issues"
  },
  "dependencies": {
    "binary-search": "^1.3.2",
    "tera-data-parser": "github:meishuu/tera-data-parser-js"
  },
  "description": "Modular event handling through a TERA proxy server.",
  "devDependencies": {
    "eslint": "^3.8.1",
    "eslint-config-google": "^0.7.0"
  },
  "engines": {
    "node": ">=6.0.0"
  },
  "gitHead": "3e704964ff2cc8b38a2f3e7b80045722f5da9aab",
  "homepage": "https://github.com/meishuu/tera-proxy-game#readme",
  "license": "GPL-3.0",
  "main": "lib/index.js",
  "name": "tera-proxy-game",
  "optionalDependencies": {},
  "peerDependencies": {
    "tera-data": "*"
  },
  "readme": "# tera-proxy-game\r\n\r\nHosts a TCP proxy server to read, modify, and inject network data between a TERA game client and server.\r\nModular system built on event-based hooks allows for easy creation and usage of script mods.\r\n\r\n## Example\r\n```coffeescript\r\nGameProxy = require 'game'\r\n\r\nserver = GameProxy.createServer { host: '208.67.49.92', port: 10001 },\r\n  (dispatch) -> dispatch.load 'logger'\r\n\r\nserver.listen 9247, '127.0.0.1', ->\r\n  address = server.address()\r\n  console.log 'listening on %s:%d', address.address, address.port\r\n```\r\n\r\n## Building a Module\r\n\r\nA module loaded through `dispatch.load(name)` is instantiated similarly to:\r\n\r\n```coffeescript\r\nmodule = require name\r\nmodules[name] = new module dispatch\r\n```\r\n\r\nThus, a loadable module's export must be a function. Since this function is called with `new`,\r\nthe context of `this` will be unique to each connection to the proxy.\r\n\r\nAs an example of a simple module, we can set up a hook on `sSpawnUser` to turn everyone else into an elin:\r\n\r\n```coffeescript\r\nmodule.exports = (dispatch) ->\r\n  # set up a pre hook\r\n  dispatch.hook 'sSpawnUser', (event) ->\r\n    # calculate the user's class from the model\r\n    job = (event.model - 10101) % 100\r\n    \r\n    # if the user is a gunner (9) or brawler (10),\r\n    if job > 8\r\n      # don't do anything\r\n      return\r\n\r\n    # calculate the user's race from the model\r\n    race = (event.model - 10101) // 100\r\n    \r\n    # modify the model \r\n    event.model += (9 - race) * 100\r\n    \r\n    # return\r\n    true # marks the event object as having changed\r\n```\r\n\r\nFor a slightly more complex example, we can make a module that replaces the string `{me}` in\r\nchat messages with the name of the character being played.\r\n\r\n```coffeescript\r\n# export a class rather than a simple function as an example\r\nmodule.exports = class Me\r\n  # set up hooks in the constructor\r\n  constructor: (dispatch) ->\r\n    # initialize properties\r\n    @name = ''\r\n\r\n    # hook sLogin to save character name\r\n    dispatch.hook 'sLogin', @onLogin.bind @\r\n    \r\n    # hook cChat and cWhisper to replace \"{me}\"\r\n    dispatch.hook 'cChat', @onChat.bind @\r\n    dispatch.hook 'cWhisper', @onChat.bind @\r\n\r\n  # method used as event handler for sLogin\r\n  onLogin: (event) ->\r\n    # save character name\r\n    @name = event.name\r\n\r\n    # explicit return ensures that this hook will not cause the message to be\r\n    # dropped or reconstructed\r\n    return\r\n\r\n  # method used as event handler for cChat and cWhisper\r\n  onChat: (event) ->\r\n    # replace {me} with the name of our character (from object property)\r\n    message = event.message.replace /\\{me\\}/g, @name\r\n    \r\n    # if the message changed,\r\n    if message isnt event.message\r\n      # save the new value in the event object\r\n      event.message = message\r\n\r\n      # return value of true will flag the event object as modified\r\n      true # this will cause the message to be reconstructed\r\n```\r\n\r\n## The Protocol\r\n\r\nThe `def/` directory holds all the definitions for messages, including a mapping of message names to opcodes in `_map.def`.\r\nGenerally, `_map.def` will need to be updated on every major version bump of TERA. One method of easily accomplishing this\r\nis written in [GoneUp's Tera Packet Viewer](https://github.com/GoneUp/Tera_PacketViewer/blob/Dev/Opcode%20DLL/README.txt).\r\nNote that the official message names are converted to camel case, e.g., `S_SPAWN_USER` becomes `sSpawnUser` here.\r\n\r\nAll other `.def` files must be named after a message and contain a list of field type and name information. This is used\r\nto both parse the raw network data into a JavaScript object and convert said object back into a buffer. As an example from\r\n`sGuildHistory`:\r\n\r\n```\r\ncount  events\r\noffset events\r\n\r\nint32 page\r\nint32 pages\r\narray events\r\n- offset initiator\r\n- offset description\r\n- int64  date\r\n- int32  event\r\n- string initiator\r\n- string description\r\n```\r\n\r\nA line must consist of:\r\n * An optional series of `-` for array definitions. These may be separated by spaces.\r\n   To nest arrays, just add one more `-` to the front.\r\n * A field type. Valid types listed below.\r\n * At least one space.\r\n * A field name to be used for the resulting JavaScript object.\r\n\r\nA `#` and anything after it on the line are comments and will be ignored when parsing.\r\n\r\nThe following field types are supported:\r\n\r\n * `array`: Converts to a JavaScript array. Both `count` and `offset` metatypes are required for this field.\r\n   This implicitly includes an `offset here` and an `offset next` at the beginning of each array item.\r\n * `byte`: A single byte. Also used for booleans.\r\n * `bytes`: Converts to a [Node `Buffer`](https://nodejs.org/api/buffer.html).\r\n   Both `count` and `offset` metatypes are required for this field.\r\n * `count`, `offset`: Synonymous with `uint16`. `count` dictates the length of an `array` or `bytes` field, while\r\n   `offset` indicates the byte offset from the beginning of the message for `array`, `bytes`, and `string`.\r\n * `int16`, `uint16`, `int32`, `uint32`, `float`: Self-explanatory.\r\n * `int64`, `uint64`: Converts to an `Int64` object; see below.\r\n * `string`: Reads a sequence of `uint16`, ending when `NUL` (`0x0000`) is encountered. Converts to a normal JavaScript string.\r\n   `offset` is required for this field.\r\n\r\nSince JavaScript only supports numbers to 53 bits of precision, an `Int64` object must be used for 64-bit integers.\r\nIt contains the properties `low` and `high` as well as an `equals()` method to compare against other `Int64`s.\r\n\r\n## API Reference\r\n\r\n### `Dispatch`\r\n\r\nAn instance of `Dispatch` is created for every connection to the proxy game server.\r\n\r\n * `hook(name, [type], cb)`\r\n * `unhook(name, [type], cb)`\r\n\r\nAdds or removes a hook for a message.\r\n\r\n`name` will usually be the name of the message being watched for, but it can also be `\"*\"` to catch all messages.\r\nIf `\"*\"` is used, then `type` is forced to `\"raw\"`.\r\n\r\n`type` defaults to `\"pre\"` for a pre-hook, which will pass the parsed message data as an argument to `cb`.\r\n`type` can also be `\"raw\"`, in which case a `Buffer` containing the raw message data will be passed instead.\r\nIf `name` is `\"*\"`, this will always be `\"raw\"`.\r\n\r\n`cb` receives:\r\n * For a `pre` hook,\r\n   * `event`: The `Object` of the parsed message data.\r\n   * Return value is `true` if `event` is modified, or `false` to stop and silence the message.\r\n     Other return values are ignored.\r\n * For a `raw` hook,\r\n   * `code`: The opcode of the message as an integer.\r\n   * `data`: The `Buffer` of the raw message data.\r\n   * `fromServer`: `true` if the message was sent by the server, `false` otherwise.\r\n   * Return value is a `Buffer` of the modified message data to use, or `false` to stop and silence the message.\r\n     Other return values are ignored.\r\n\r\nWhen a hooked message is received, `Dispatch` performs the following sequence of actions:\r\n\r\n 1. Run all `*` hooks.\r\n    * If a `Buffer` is returned, use it as the new data buffer.\r\n    * If `false` is returned, exit immediately and do not forward the message.\r\n    * Otherwise, keep executing hooks.\r\n 2. Run all `raw` hooks. Return values are interpreted the same as above.\r\n 3. If there are any `pre` hooks, parse the message data into an object and then run all `pre` hooks.\r\n    * If `true` is returned, the hook is signifying that it has modified the event object and\r\n      it will need to be repacked into a `Buffer` when all hooks have been called.\r\n    * If `false` is returned, exit immediately and do not forward the message.\r\n    * Otherwise, keep executing hooks.\r\n 4. Reconstruct the message data if necessary, and forward it to the intended recipient.\r\n\r\nNote that if a `pre` hook changes the event object but no `pre` hook returns `true`, the changes will not\r\nbe saved because `Dispatch` will not know to reconstruct the message.\r\n\r\n * `toClient(buffer)`\r\n * `toClient(name, data)`\r\n * `toServer(buffer)`\r\n * `toServer(name, data)`\r\n\r\nConstructs and sends a packet to either the TERA client or server.\r\n\r\nIf `buffer` is used, it will simply be sent as-is (before encryption).\r\n\r\nIf `data` is used, `name` must be the message name.\r\n\r\n * `load(name, [from])`\r\n\r\nLoad the module referenced by `name` using `from.require()`. You will likely want to pass the `module`\r\nfrom the calling context in order to emulate a `require()` from there; otherwise, it will default to\r\nloading the module as if `require()` were called from inside `dispatch.coffee`. See the\r\n[module.require documentation](https://nodejs.org/api/modules.html#modules_module_require_id) for more\r\ndetails.\r\n\r\nReturns `true` if successful, `false` otherwise.\r\n\r\n * `unload(name)`\r\n\r\nUnloads the module referenced by `name`, calling the `destructor()` method on the module if it exists.\r\nThis does not automatically remove hooks, which should be done in `destructor()`.\r\n\r\nReturns `true` if successful, `false` otherwise.\r\n\r\n * `close()`\r\n\r\nUnloads all modules and removes all hooks.\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/meishuu/tera-proxy-game.git"
  },
  "scripts": {
    "lint": "eslint ."
  },
  "version": "1.0.0"
}
